// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


////////// ENUMS /////////

enum Role {
  SUPERADMIN
  ADMIN
  USER
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE
  AUDIO
  SYSTEM
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
}

enum GroupRole {
  MEMBER
  ADMIN
}

enum DeliveryChannel {
  SOCKET
  PUSH
  WEBHOOK
  UNKNOWN
}

enum DeliveryStatus {
  QUEUED // created but not attempted
  SENT // server attempted delivery (socket/push/webhook)
  DELIVERED // client acknowledged receipt
  READ // user read the message
  FAILED
}

//////// MODELS ////////

model Device {
  id       String @id @default(uuid())
  deviceId String? // external device identifier from client
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  publicKeyB64 String // Base64-encoded ECDH/RSA public key
  lastSeen     DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  

  @@index([userId])
}

model User {
  id              String    @id @default(uuid())
  email           String    @unique
  password        String
  username        String?   @unique
  role            Role
  firstName       String?
  lastName        String?
  avatar          String?
  isActive        Boolean   @default(true)
  isVerified      Boolean   @default(false)
  isfirstLoggedIn Boolean   @default(true)
  lastLogin       DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  keys            UserKey?
  isNotification  Boolean @default(true)

  // Relations
  devices              Device[]
  groupMemberships     GroupMember[]
  conversationMembers  ConversationMember[]
  messagesSent         Message[]            @relation("UserMessages")
  refreshTokens        RefreshToken[]
  passwordResets       PasswordReset[]
  MessageRead          MessageRead[]
  messageDeliveries    MessageDelivery[]    @relation("UserMessageDeliveries")
   auditActorEvents     AuditLog[] @relation("AuditActor")
  auditRecipientEvents AuditLog[] @relation("AuditRecipient")
  fcmTokens            FcmToken[]
  groupKeyEnvelopes    GroupKeyEnvelope[]
  recentSearches       RecentSearch[]
  reactions            MessageReaction[] @relation("UserReactions")
}

model UserKey {
  id            String   @id @default(uuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id])
  publicKey     String // PEM/Base64 RSA public key
  privateKeyEnc String // Encrypted private key (optional, store only if needed)
  createdAt     DateTime @default(now())
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  deviceId  String? 
  userAgent String? // Browser/app identification
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Relations
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

model PasswordReset {
  id        String   @id @default(uuid())
  email     String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [email], references: [email], onDelete: Cascade)

  @@map("password_resets")
}

model Conversation {
  id          String               @id @default(uuid())
  isGroup     Boolean              @default(false)
  members     ConversationMember[]
  messages    Message[]            @relation("ConversationMessages")
  bundleKey   String?              @unique
  convoKeyEnc String? // AES-GCM encrypted conversation symmetric key (JSON string)
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  auditEvents AuditLog[] @relation("AuditConversation")
}

model ConversationMember {
  id             String @id @default(uuid())
  userId         String
  conversationId String

  user         User         @relation(fields: [userId], references: [id])
  conversation Conversation @relation(fields: [conversationId], references: [id])

  @@unique([userId, conversationId])
}

model Group {
  id         String        @id @default(uuid())
  name       String
  profileImg String?
  archived   Boolean       @default(false)
  members    GroupMember[]
  messages   Message[]     @relation("GroupMessages")
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  version    Int? // üëà make optional
  gskB64     String?

  auditEvents AuditLog[] @relation("AuditGroup")
  groupKeys         GroupKey[]
  keyRequests       KeyRequest[]
  groupKeyEnvelopes GroupKeyEnvelope[]
   recentSearches RecentSearch[] 
}

model GroupMember {
  id      String    @id @default(uuid())
  userId  String
  groupId String
  role    GroupRole

  user  User  @relation(fields: [userId], references: [id])
  group Group @relation(fields: [groupId], references: [id])

  joinedAt DateTime @default(now())

  @@unique([userId, groupId])
  @@index([userId])
  @@index([groupId])
}

model Message {
  id              String        @id @default(uuid())
  conversationId  String? // For 1-on-1 chats
  groupId         String? // For group/clinic chats
  senderId        String
  encryptedText   String?
  type            MessageType
  status          MessageStatus @default(SENT)
  fileUrl         String?
  createdAt       DateTime      @default(now())
  iv              String?
  aesKeyEncB64Url String?
  version         Int?
  fileName        String?
  fileType        String?
  fileSize        String?
  filePages       Int?       

  // Relations
  conversation Conversation? @relation("ConversationMessages", fields: [conversationId], references: [id])
  group        Group?        @relation("GroupMessages", fields: [groupId], references: [id])
  sender       User          @relation("UserMessages", fields: [senderId], references: [id])

  reads       MessageRead[]     @relation("MessageReads")
  deliveries  MessageDelivery[] @relation("MessageDeliveries")
  auditEvents AuditLog[] @relation("AuditMessage")
  reactions   MessageReaction[] @relation("MessageReactions")

  @@index([conversationId, createdAt])
  @@index([groupId, createdAt])
  @@index([senderId, createdAt])
}

model MessageRead {
  id          String    @id @default(uuid())
  userId      String
  messageId   String
  readAt      DateTime?
  deliveredAt DateTime?

  user    User    @relation(fields: [userId], references: [id])
  message Message @relation(fields: [messageId], references: [id], name: "MessageReads")

  @@unique([userId, messageId])
  @@index([userId, readAt])
  @@index([userId, deliveredAt])
  @@index([messageId, readAt])
}

model MessageReaction {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  emoji     String   // The emoji string (e.g., "üëç", "‚ù§Ô∏è", "üòÇ")
  createdAt DateTime @default(now())

  // Relations
  message Message @relation("MessageReactions", fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation("UserReactions", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId]) // One reaction per user per message (like iMessage)
  @@index([messageId])
  @@index([userId])
}

model FcmToken {
  id         String   @id @default(uuid())
  token      String
  deviceType String?
  deviceId   String?
  createdAt  DateTime @default(now())

  // Relation to User
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  @@index([userId])
}

model GroupKey {
  id        String   @id @default(uuid())
  groupId   String
  version   Int? 
  gskB64    String? 
  createdAt DateTime @default(now())

  group Group @relation(fields: [groupId], references: [id])

  @@index([groupId, version]) 
}

model GroupKeyEnvelope {
  id              String   @id @default(uuid())
  groupId         String
  userId          String
  version         Int
  aesKeyEncB64Url String 
  createdAt       DateTime @default(now())

  // Relations
  group Group @relation(fields: [groupId], references: [id])
  user  User  @relation(fields: [userId], references: [id])


  @@unique([groupId, userId, version]) 
  @@index([groupId])
  @@index([userId])
}

model KeyRequest {
  id           String    @id @default(uuid())
  groupId      String
  targetUserId String
  version      Int
  status       String    @default("PENDING") 
  createdAt    DateTime  @default(now())
  fulfilledAt  DateTime?
  requestedBy  String? 
  note         String?

  group Group @relation(fields: [groupId], references: [id])

  @@index([groupId, targetUserId, version, status])
}

model MessageDelivery {
  id            String          @id @default(uuid())
  messageId     String
  recipientId   String
  status        DeliveryStatus  @default(QUEUED)
  lastChannel   DeliveryChannel @default(UNKNOWN)
  deliveredAt   DateTime?
  firstReadAt   DateTime?
  lastReadAt    DateTime?
  readCount     Int             @default(0)
  lastDeviceId  String?
  lastUserAgent String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  // FKs (to your existing tables)
  message   Message @relation("MessageDeliveries", fields: [messageId], references: [id])
  recipient User    @relation("UserMessageDeliveries", fields: [recipientId], references: [id])

  @@unique([messageId, recipientId])
  @@index([recipientId])
  @@index([status])
  @@index([messageId, updatedAt])
  @@index([recipientId, deliveredAt])
  @@index([recipientId, lastReadAt])
}

/// Append-only immutable audit stream for compliance exports
model AuditLog {
  id             String   @id @default(cuid())
  actorUserId    String?
  recipientUserId String?
  eventType      String   // e.g. MESSAGE_CREATED, DELIVERY_ATTEMPTED
  messageId      String?
  conversationId String?
  groupId        String?
  metadata       Json?
  createdAt      DateTime @default(now())

 actor     User?         @relation("AuditActor", fields: [actorUserId], references: [id])
  recipient User?         @relation("AuditRecipient", fields: [recipientUserId], references: [id])
  message   Message?      @relation("AuditMessage", fields: [messageId], references: [id])
  conversation Conversation? @relation("AuditConversation", fields: [conversationId], references: [id])
  group     Group?        @relation("AuditGroup", fields: [groupId], references: [id])
}


model RecentSearch {
  id        String   @id @default(uuid())
  userId    String
  groupId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId]) // prevent duplicates (1 record per user+group)
  @@index([userId])
  @@index([groupId])
}